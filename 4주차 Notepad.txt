4주차 Notepad

 - 함수의 정의
   => 함수란 프로그램을 구성하는 단위로써 프로그램의 부품 역할을 한다.
   =>가장 핵심이 되는 함수(=main)의 통제 아래 모든 함수들이 체계적으로 실행되어 전체적으로 프로그램이라는 하나의 완성을 이룸.
       (C++에서는 함수의 이런 부품 역할을 객체가 대신 한다.)

 1) 표준함수 : C언어와 함꼐 작성되어 제공되는 것이며, 컴파일러와 함께 배포된다.
                  함수의 기능과 호출하는 방법만 알고 있으며 언제든지 불러서 사용할 수 있음

 2) 사용자 정의 함수 : 개발자가 필요에 따라 만들어 쓰는 함수(목적에 따라 적합한 함수를 만들어 씀)
   => type name(인수목록)
        {
             함수의 본체
        }
  1. name : 함수의 이름이며, 이 이름을 통해 함수를 호출한다.

  2. 인수 목록 : 함수가 해야 할 일의 세부 사항을 지정하며, 함수의 작업거리라고 할 수 있다.
                    함수의 동작에 필요한 인수는 없을 수도 있고, 여러 개일 수도 있는데 인수 목록에 필요한 인수의 타입과 이름을 밝힌다.
                    (ex. PrintScore(int Score)) - 인수는 필요한만큼 사용할 수 있으며, 개수의 제한은 없다.

  3. type : 함수가 리턴하는 값의 데이터형이며, 함수의 작업 결과라고 할 수 있다. 
              함수는 고유의 작업을 실행하고 그 결과를 호출원에게 다시 돌려 준다.
              (@단순히 어떤 기능만 수행하는 함수라면, 리턴하는 값이 없을 수도 있는데 이런 함수를 void함수라고 한다.)

  4. 본체 : {}괄호안에 실제 함수의 코드가 위치한다. 이 블록 안에 함수의 고유 기능을 수행하는 코드를 작성
  - 주의할 점 : 인수가 없는 함수의 경우 ~()식으로 함수 이름 뒤에 빈 괄호만 써줌. - 괄호 생략 불가

  5. 인수 : 호출원에서 함수에게 넘겨주는 작업 대상 / 일명 매개변수라고도 함.
             인수가 없는 함수는 인수 목록을 비워 두거나 인수를 받지 않는다는 것을 분명히 표시하기 위해 인수 목록에 void라고 적는다.

  - 형식 인수 : 인수 목록에 나타나는 인수 / 실인수 : 함수 호출부에서 함수와 함께 전달되는 인수  

   6. return : 함수가 호출원으로 돌려주는 작업 결과
   - 일반적인 기능 : 함수의 결과값을 호출원으로 돌려주는 것 / 두번쨰 기능 : 결과를 돌려주는 것 외에 함수를 강제 종료시키는 기능
                          (두번쨰 기능은 인수의 유효성 검사할 떄 많이 사용한다.)
   - main함수에서 return문은 exit(0)와 효과가 같다.

   7. void형 함수 : 리턴할 값이 없는 함수 - 내부적으로 작업만 할 뿐, 계산 결과를 리턴하지 않으므로, 호출원에서는 함수를 호출만 하며 리턴값을 대입받거나 사용하지 말아야 한다.


   - 함수 : 특정 계산을 수행하며 리턴값이 있음 / 반드시 수식내에서만 사용할 수 있으며, 함수 단독으로 문장을 구성할 수 없다.
   - 프로시저 : 특정 작업을 수행하며 리턴값이 없다. C의 void함수가 이에 해당한다.

   - 함수 중에서 가장 기본이 되는 함수를 main이라고 하며, 프로그램의 시작점이 된다.(프로그램의 실행 시작점!!)
   - 리턴값이 있는 함수는 리턴 타입을 가지며, 그렇지 않은 함수는 void형으로 선언하면 된다.

----------------------------------------------------------------------------

   - 함수의 원형
   1) 1패스 방식 : 소스를 순서대로 번역하므로 main 함수보다 함수가 먼저 선언되어야함
   2) 원형을 선언한다는 것 : 함수가 사용되기 전에 미리 그 형태를 컴파일러가 알 수 있도록 하는 것
     (함수에 대한 정보를 제공하기 위해 작성하기 떄문에, 리턴 타입, 함수 이름, 인수 목록만 적는다.)

   3) 헤더파일 : 표준 함수의 원형을 미리 작성해 놓은 것(대표적 : stdio.h / conio.h / stdlib.h)
   4) 다중 모듈 컴파일 방식 : 하나의 실행 파일을 만들기 위한 소스를 여러 개로 나누어 개발하는 방식
     - 컴파일 속도가 빠름 : 함수들이 여러 개의 모듈에 분산되어 있으므로, 한 함수를 수정한 후 컴파일 할 떄 이 함수가 속한 모듈만 컴파일하면 된다.
     - 분담 작업이 가능 : 각 분야의 전문가들이 분담을 해서 자신의 능력을 최대한 발휘 가능
     - 프로젝트 관리가 쉬움 : 모듈별로 관련 함수들을 모아 놓았기 때문에 문제발생시 수정하기 쉽다.
     - 모듈 재사용 가능 : 모듈은 기능적으로 독립적인 함수의 집합을 구성하기 때문에 다른 프로젝트에도 적용 가능 
     (다른 컴파일 코드를 가져올떄 사용하는 헤더 방식 : #include "~" => <>가 아닌 ""로 불러옴)

----------------------------------------------------------------------------------

  - 함수 호출 방식
   1) 값 호출방식(call by value) : 실인수의 값이 형식 인수로 전달되는 방식 => 형식 인수가 함수내에서 변경되더라도 실인수에는 전혀 영향을 미치지 않음
   2) 참조 호출 방식(call by reference) : 실인수의 값을 전달하는 것이 아니라 실인수의 번지를 전달하는 방식임.

   - 출력을 하는 인수는 항상 초기화를 해줄 필요는 없지만 입력을 하는 인수는 항상 초기화를 해줘야 한다(쓰레기 값이 들어가기 때문!)

   - C++은 포인터를 이용하는 방법외에 래퍼런스라는 개념으로 참조 호출을 추가로 지원함.

 ----------------------------------------------------------------------------------

   - 포인터 : 메모리 주소와 연관되어 있는 문법(메모리 주소값을 저장할 수 있는 자료형이 포인터 / 포인터도 하나의 타입이다.)
   - 포인터 문법(#선언할 떄!, 주소 값을 저장할 때)
   1) 포인터 변수를 선언할 때는 데이터형을 먼저 쓰고, *를 쓴 다음, 변수명을 적어준다.(곱하기할 떄 사용하는 연산자 '*'와 기호는 같지만 다른 연산자임.)
      (ex. char* : char형 변수의 주소 값 / int* : int형 변수의 주소 값)
   2) 포인터 변수 값이 할당되지 않았을 경우, 초기화는 NULL / nullptr 키워드를 사용해서 초기화할것
   3) 포인터 변수의 크기는 포인터 변수가 가리키는 변수의 데이터형에 관계없이 4바이트로 항상 같습니다.
   4) 포인터 역참조 : 포인터 변수에 저장되어 있는 주소를 역으로 참조해 그 주소가 가지고 있는 실제 값을 가져옴(자료형 사용 X)
   5) 포인터 사용시 주의사항 : 포인터 변수를 선언만 하고 초기화하지 않으면, 포인터 변수는 쓰레기 값으로 초기화 됨
                                        나중에 주소값을 저장할 예정이라면, 널포인터로 초기화 하는것이 바람직함.
   6) 메모리의 주소값을 저장하기 위해서는 반드시 포인터 변수로 받아야 함을 명심하자!(일반 변수로 받게 되면 주소값을 가져오지 못함!)

--------------------------------------------------------------------------------------

   - 전처리기 : 컴파일하기 전에 소스를 재작성하는 역할을 함
   1) C에서 제공하는 표준 헤더파일을 포함시키고자 할떄 <>괄호를 사용한다.
   2) 사용자가 직접 작성한 헤더파일을 포함시키고자 할 떄 ""괄호를 사용한다.
   3) #define 전처리문은 매크로 상수를 정의하는데 사용된다. => 매크로 상수를 정의하면 가독성이 좋아지고 코드를 이해하기 편해짐
                                                                                     특정값의 일괄적인 수정을 위해서도 유용하게 사용됨(두 번 이상 사용될 가능성이 있는 상수라면 매크로 상수를 정의해서 사용하는 것이 좋음)
                                                                                     전처리문은 코드를 생성하는 명령이 아니기 떄문에 세미콜론은 붙이지 않는다.
                                                                                     매크로 함수 호출문에서는 증감연산자나 복합 대입 연산자는 쓰지 않는 것이 좋다.
    (ex. #define printmsg(x,y,str){gotoxy(x,y);puts(str);}) => gotoxy함수를 호출하여 커서를 x,y로 옮기고 이 자리에 str을 출력한다.

   - C프로그램의 구조
   (#include <......>
    #define ......
     함수의 원형
     전역 변수
 
     void main()
     {
            코드
     }
     함수
     함수
     함수                       )
    - 주의사항 : 헤더파일과 매크로 함수의 위치가 바뀌면 치명적인 에러가 날 수 있으니 주의할것!